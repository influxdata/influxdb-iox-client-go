// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ManagementServiceClient is the client API for ManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagementServiceClient interface {
	GetServerId(ctx context.Context, in *GetServerIdRequest, opts ...grpc.CallOption) (*GetServerIdResponse, error)
	UpdateServerId(ctx context.Context, in *UpdateServerIdRequest, opts ...grpc.CallOption) (*UpdateServerIdResponse, error)
	SetServingReadiness(ctx context.Context, in *SetServingReadinessRequest, opts ...grpc.CallOption) (*SetServingReadinessResponse, error)
	ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (*ListDatabasesResponse, error)
	GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error)
	CreateDatabase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*CreateDatabaseResponse, error)
	// Update a database.
	//
	// Roughly follows the <https://google.aip.dev/134> pattern, except we wrap the response
	UpdateDatabase(ctx context.Context, in *UpdateDatabaseRequest, opts ...grpc.CallOption) (*UpdateDatabaseResponse, error)
	// List chunks available on this database
	ListChunks(ctx context.Context, in *ListChunksRequest, opts ...grpc.CallOption) (*ListChunksResponse, error)
	// List remote IOx servers we know about.
	ListRemotes(ctx context.Context, in *ListRemotesRequest, opts ...grpc.CallOption) (*ListRemotesResponse, error)
	// Update information about a remote IOx server (upsert).
	UpdateRemote(ctx context.Context, in *UpdateRemoteRequest, opts ...grpc.CallOption) (*UpdateRemoteResponse, error)
	// Delete a reference to remote IOx server.
	DeleteRemote(ctx context.Context, in *DeleteRemoteRequest, opts ...grpc.CallOption) (*DeleteRemoteResponse, error)
	// Creates a dummy job that for each value of the nanos field
	// spawns a task that sleeps for that number of nanoseconds before returning
	CreateDummyJob(ctx context.Context, in *CreateDummyJobRequest, opts ...grpc.CallOption) (*CreateDummyJobResponse, error)
	// List partitions in a database
	ListPartitions(ctx context.Context, in *ListPartitionsRequest, opts ...grpc.CallOption) (*ListPartitionsResponse, error)
	// Get detail information about a partition
	GetPartition(ctx context.Context, in *GetPartitionRequest, opts ...grpc.CallOption) (*GetPartitionResponse, error)
	// List chunks in a partition
	ListPartitionChunks(ctx context.Context, in *ListPartitionChunksRequest, opts ...grpc.CallOption) (*ListPartitionChunksResponse, error)
	// Create a new chunk in the mutable buffer
	NewPartitionChunk(ctx context.Context, in *NewPartitionChunkRequest, opts ...grpc.CallOption) (*NewPartitionChunkResponse, error)
	// Close a chunk and move it to the read buffer
	ClosePartitionChunk(ctx context.Context, in *ClosePartitionChunkRequest, opts ...grpc.CallOption) (*ClosePartitionChunkResponse, error)
	// Unload chunk from read buffer but keep it in object store
	UnloadPartitionChunk(ctx context.Context, in *UnloadPartitionChunkRequest, opts ...grpc.CallOption) (*UnloadPartitionChunkResponse, error)
	// Get server status
	GetServerStatus(ctx context.Context, in *GetServerStatusRequest, opts ...grpc.CallOption) (*GetServerStatusResponse, error)
	// Wipe preserved catalog for given DB.
	WipePreservedCatalog(ctx context.Context, in *WipePreservedCatalogRequest, opts ...grpc.CallOption) (*WipePreservedCatalogResponse, error)
	// Skip replay for given DB.
	SkipReplay(ctx context.Context, in *SkipReplayRequest, opts ...grpc.CallOption) (*SkipReplayResponse, error)
	// Drop partition from memory and (if persisted) from object store.
	DropPartition(ctx context.Context, in *DropPartitionRequest, opts ...grpc.CallOption) (*DropPartitionResponse, error)
}

type managementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewManagementServiceClient(cc grpc.ClientConnInterface) ManagementServiceClient {
	return &managementServiceClient{cc}
}

func (c *managementServiceClient) GetServerId(ctx context.Context, in *GetServerIdRequest, opts ...grpc.CallOption) (*GetServerIdResponse, error) {
	out := new(GetServerIdResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/GetServerId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) UpdateServerId(ctx context.Context, in *UpdateServerIdRequest, opts ...grpc.CallOption) (*UpdateServerIdResponse, error) {
	out := new(UpdateServerIdResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/UpdateServerId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) SetServingReadiness(ctx context.Context, in *SetServingReadinessRequest, opts ...grpc.CallOption) (*SetServingReadinessResponse, error) {
	out := new(SetServingReadinessResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/SetServingReadiness", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (*ListDatabasesResponse, error) {
	out := new(ListDatabasesResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/ListDatabases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) GetDatabase(ctx context.Context, in *GetDatabaseRequest, opts ...grpc.CallOption) (*GetDatabaseResponse, error) {
	out := new(GetDatabaseResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/GetDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) CreateDatabase(ctx context.Context, in *CreateDatabaseRequest, opts ...grpc.CallOption) (*CreateDatabaseResponse, error) {
	out := new(CreateDatabaseResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/CreateDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) UpdateDatabase(ctx context.Context, in *UpdateDatabaseRequest, opts ...grpc.CallOption) (*UpdateDatabaseResponse, error) {
	out := new(UpdateDatabaseResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/UpdateDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ListChunks(ctx context.Context, in *ListChunksRequest, opts ...grpc.CallOption) (*ListChunksResponse, error) {
	out := new(ListChunksResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/ListChunks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ListRemotes(ctx context.Context, in *ListRemotesRequest, opts ...grpc.CallOption) (*ListRemotesResponse, error) {
	out := new(ListRemotesResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/ListRemotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) UpdateRemote(ctx context.Context, in *UpdateRemoteRequest, opts ...grpc.CallOption) (*UpdateRemoteResponse, error) {
	out := new(UpdateRemoteResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/UpdateRemote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) DeleteRemote(ctx context.Context, in *DeleteRemoteRequest, opts ...grpc.CallOption) (*DeleteRemoteResponse, error) {
	out := new(DeleteRemoteResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/DeleteRemote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) CreateDummyJob(ctx context.Context, in *CreateDummyJobRequest, opts ...grpc.CallOption) (*CreateDummyJobResponse, error) {
	out := new(CreateDummyJobResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/CreateDummyJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ListPartitions(ctx context.Context, in *ListPartitionsRequest, opts ...grpc.CallOption) (*ListPartitionsResponse, error) {
	out := new(ListPartitionsResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/ListPartitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) GetPartition(ctx context.Context, in *GetPartitionRequest, opts ...grpc.CallOption) (*GetPartitionResponse, error) {
	out := new(GetPartitionResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/GetPartition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ListPartitionChunks(ctx context.Context, in *ListPartitionChunksRequest, opts ...grpc.CallOption) (*ListPartitionChunksResponse, error) {
	out := new(ListPartitionChunksResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/ListPartitionChunks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) NewPartitionChunk(ctx context.Context, in *NewPartitionChunkRequest, opts ...grpc.CallOption) (*NewPartitionChunkResponse, error) {
	out := new(NewPartitionChunkResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/NewPartitionChunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) ClosePartitionChunk(ctx context.Context, in *ClosePartitionChunkRequest, opts ...grpc.CallOption) (*ClosePartitionChunkResponse, error) {
	out := new(ClosePartitionChunkResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/ClosePartitionChunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) UnloadPartitionChunk(ctx context.Context, in *UnloadPartitionChunkRequest, opts ...grpc.CallOption) (*UnloadPartitionChunkResponse, error) {
	out := new(UnloadPartitionChunkResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/UnloadPartitionChunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) GetServerStatus(ctx context.Context, in *GetServerStatusRequest, opts ...grpc.CallOption) (*GetServerStatusResponse, error) {
	out := new(GetServerStatusResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/GetServerStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) WipePreservedCatalog(ctx context.Context, in *WipePreservedCatalogRequest, opts ...grpc.CallOption) (*WipePreservedCatalogResponse, error) {
	out := new(WipePreservedCatalogResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/WipePreservedCatalog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) SkipReplay(ctx context.Context, in *SkipReplayRequest, opts ...grpc.CallOption) (*SkipReplayResponse, error) {
	out := new(SkipReplayResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/SkipReplay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementServiceClient) DropPartition(ctx context.Context, in *DropPartitionRequest, opts ...grpc.CallOption) (*DropPartitionResponse, error) {
	out := new(DropPartitionResponse)
	err := c.cc.Invoke(ctx, "/influxdata.iox.management.v1.ManagementService/DropPartition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagementServiceServer is the server API for ManagementService service.
// All implementations must embed UnimplementedManagementServiceServer
// for forward compatibility
type ManagementServiceServer interface {
	GetServerId(context.Context, *GetServerIdRequest) (*GetServerIdResponse, error)
	UpdateServerId(context.Context, *UpdateServerIdRequest) (*UpdateServerIdResponse, error)
	SetServingReadiness(context.Context, *SetServingReadinessRequest) (*SetServingReadinessResponse, error)
	ListDatabases(context.Context, *ListDatabasesRequest) (*ListDatabasesResponse, error)
	GetDatabase(context.Context, *GetDatabaseRequest) (*GetDatabaseResponse, error)
	CreateDatabase(context.Context, *CreateDatabaseRequest) (*CreateDatabaseResponse, error)
	// Update a database.
	//
	// Roughly follows the <https://google.aip.dev/134> pattern, except we wrap the response
	UpdateDatabase(context.Context, *UpdateDatabaseRequest) (*UpdateDatabaseResponse, error)
	// List chunks available on this database
	ListChunks(context.Context, *ListChunksRequest) (*ListChunksResponse, error)
	// List remote IOx servers we know about.
	ListRemotes(context.Context, *ListRemotesRequest) (*ListRemotesResponse, error)
	// Update information about a remote IOx server (upsert).
	UpdateRemote(context.Context, *UpdateRemoteRequest) (*UpdateRemoteResponse, error)
	// Delete a reference to remote IOx server.
	DeleteRemote(context.Context, *DeleteRemoteRequest) (*DeleteRemoteResponse, error)
	// Creates a dummy job that for each value of the nanos field
	// spawns a task that sleeps for that number of nanoseconds before returning
	CreateDummyJob(context.Context, *CreateDummyJobRequest) (*CreateDummyJobResponse, error)
	// List partitions in a database
	ListPartitions(context.Context, *ListPartitionsRequest) (*ListPartitionsResponse, error)
	// Get detail information about a partition
	GetPartition(context.Context, *GetPartitionRequest) (*GetPartitionResponse, error)
	// List chunks in a partition
	ListPartitionChunks(context.Context, *ListPartitionChunksRequest) (*ListPartitionChunksResponse, error)
	// Create a new chunk in the mutable buffer
	NewPartitionChunk(context.Context, *NewPartitionChunkRequest) (*NewPartitionChunkResponse, error)
	// Close a chunk and move it to the read buffer
	ClosePartitionChunk(context.Context, *ClosePartitionChunkRequest) (*ClosePartitionChunkResponse, error)
	// Unload chunk from read buffer but keep it in object store
	UnloadPartitionChunk(context.Context, *UnloadPartitionChunkRequest) (*UnloadPartitionChunkResponse, error)
	// Get server status
	GetServerStatus(context.Context, *GetServerStatusRequest) (*GetServerStatusResponse, error)
	// Wipe preserved catalog for given DB.
	WipePreservedCatalog(context.Context, *WipePreservedCatalogRequest) (*WipePreservedCatalogResponse, error)
	// Skip replay for given DB.
	SkipReplay(context.Context, *SkipReplayRequest) (*SkipReplayResponse, error)
	// Drop partition from memory and (if persisted) from object store.
	DropPartition(context.Context, *DropPartitionRequest) (*DropPartitionResponse, error)
	mustEmbedUnimplementedManagementServiceServer()
}

// UnimplementedManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedManagementServiceServer struct {
}

func (UnimplementedManagementServiceServer) GetServerId(context.Context, *GetServerIdRequest) (*GetServerIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerId not implemented")
}
func (UnimplementedManagementServiceServer) UpdateServerId(context.Context, *UpdateServerIdRequest) (*UpdateServerIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateServerId not implemented")
}
func (UnimplementedManagementServiceServer) SetServingReadiness(context.Context, *SetServingReadinessRequest) (*SetServingReadinessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetServingReadiness not implemented")
}
func (UnimplementedManagementServiceServer) ListDatabases(context.Context, *ListDatabasesRequest) (*ListDatabasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDatabases not implemented")
}
func (UnimplementedManagementServiceServer) GetDatabase(context.Context, *GetDatabaseRequest) (*GetDatabaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDatabase not implemented")
}
func (UnimplementedManagementServiceServer) CreateDatabase(context.Context, *CreateDatabaseRequest) (*CreateDatabaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDatabase not implemented")
}
func (UnimplementedManagementServiceServer) UpdateDatabase(context.Context, *UpdateDatabaseRequest) (*UpdateDatabaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDatabase not implemented")
}
func (UnimplementedManagementServiceServer) ListChunks(context.Context, *ListChunksRequest) (*ListChunksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChunks not implemented")
}
func (UnimplementedManagementServiceServer) ListRemotes(context.Context, *ListRemotesRequest) (*ListRemotesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRemotes not implemented")
}
func (UnimplementedManagementServiceServer) UpdateRemote(context.Context, *UpdateRemoteRequest) (*UpdateRemoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRemote not implemented")
}
func (UnimplementedManagementServiceServer) DeleteRemote(context.Context, *DeleteRemoteRequest) (*DeleteRemoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRemote not implemented")
}
func (UnimplementedManagementServiceServer) CreateDummyJob(context.Context, *CreateDummyJobRequest) (*CreateDummyJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDummyJob not implemented")
}
func (UnimplementedManagementServiceServer) ListPartitions(context.Context, *ListPartitionsRequest) (*ListPartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPartitions not implemented")
}
func (UnimplementedManagementServiceServer) GetPartition(context.Context, *GetPartitionRequest) (*GetPartitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPartition not implemented")
}
func (UnimplementedManagementServiceServer) ListPartitionChunks(context.Context, *ListPartitionChunksRequest) (*ListPartitionChunksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPartitionChunks not implemented")
}
func (UnimplementedManagementServiceServer) NewPartitionChunk(context.Context, *NewPartitionChunkRequest) (*NewPartitionChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewPartitionChunk not implemented")
}
func (UnimplementedManagementServiceServer) ClosePartitionChunk(context.Context, *ClosePartitionChunkRequest) (*ClosePartitionChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClosePartitionChunk not implemented")
}
func (UnimplementedManagementServiceServer) UnloadPartitionChunk(context.Context, *UnloadPartitionChunkRequest) (*UnloadPartitionChunkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnloadPartitionChunk not implemented")
}
func (UnimplementedManagementServiceServer) GetServerStatus(context.Context, *GetServerStatusRequest) (*GetServerStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerStatus not implemented")
}
func (UnimplementedManagementServiceServer) WipePreservedCatalog(context.Context, *WipePreservedCatalogRequest) (*WipePreservedCatalogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WipePreservedCatalog not implemented")
}
func (UnimplementedManagementServiceServer) SkipReplay(context.Context, *SkipReplayRequest) (*SkipReplayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SkipReplay not implemented")
}
func (UnimplementedManagementServiceServer) DropPartition(context.Context, *DropPartitionRequest) (*DropPartitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropPartition not implemented")
}
func (UnimplementedManagementServiceServer) mustEmbedUnimplementedManagementServiceServer() {}

// UnsafeManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagementServiceServer will
// result in compilation errors.
type UnsafeManagementServiceServer interface {
	mustEmbedUnimplementedManagementServiceServer()
}

func RegisterManagementServiceServer(s grpc.ServiceRegistrar, srv ManagementServiceServer) {
	s.RegisterService(&ManagementService_ServiceDesc, srv)
}

func _ManagementService_GetServerId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetServerId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/GetServerId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetServerId(ctx, req.(*GetServerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_UpdateServerId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).UpdateServerId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/UpdateServerId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).UpdateServerId(ctx, req.(*UpdateServerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_SetServingReadiness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetServingReadinessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).SetServingReadiness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/SetServingReadiness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).SetServingReadiness(ctx, req.(*SetServingReadinessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ListDatabases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatabasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ListDatabases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/ListDatabases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ListDatabases(ctx, req.(*ListDatabasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_GetDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/GetDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetDatabase(ctx, req.(*GetDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_CreateDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).CreateDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/CreateDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).CreateDatabase(ctx, req.(*CreateDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_UpdateDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).UpdateDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/UpdateDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).UpdateDatabase(ctx, req.(*UpdateDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ListChunks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChunksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ListChunks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/ListChunks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ListChunks(ctx, req.(*ListChunksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ListRemotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRemotesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ListRemotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/ListRemotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ListRemotes(ctx, req.(*ListRemotesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_UpdateRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRemoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).UpdateRemote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/UpdateRemote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).UpdateRemote(ctx, req.(*UpdateRemoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_DeleteRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRemoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).DeleteRemote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/DeleteRemote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).DeleteRemote(ctx, req.(*DeleteRemoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_CreateDummyJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDummyJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).CreateDummyJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/CreateDummyJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).CreateDummyJob(ctx, req.(*CreateDummyJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ListPartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ListPartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/ListPartitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ListPartitions(ctx, req.(*ListPartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_GetPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/GetPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetPartition(ctx, req.(*GetPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ListPartitionChunks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionChunksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ListPartitionChunks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/ListPartitionChunks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ListPartitionChunks(ctx, req.(*ListPartitionChunksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_NewPartitionChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewPartitionChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).NewPartitionChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/NewPartitionChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).NewPartitionChunk(ctx, req.(*NewPartitionChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_ClosePartitionChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClosePartitionChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).ClosePartitionChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/ClosePartitionChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).ClosePartitionChunk(ctx, req.(*ClosePartitionChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_UnloadPartitionChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnloadPartitionChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).UnloadPartitionChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/UnloadPartitionChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).UnloadPartitionChunk(ctx, req.(*UnloadPartitionChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_GetServerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).GetServerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/GetServerStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).GetServerStatus(ctx, req.(*GetServerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_WipePreservedCatalog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WipePreservedCatalogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).WipePreservedCatalog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/WipePreservedCatalog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).WipePreservedCatalog(ctx, req.(*WipePreservedCatalogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_SkipReplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkipReplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).SkipReplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/SkipReplay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).SkipReplay(ctx, req.(*SkipReplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagementService_DropPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServiceServer).DropPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/influxdata.iox.management.v1.ManagementService/DropPartition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServiceServer).DropPartition(ctx, req.(*DropPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ManagementService_ServiceDesc is the grpc.ServiceDesc for ManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "influxdata.iox.management.v1.ManagementService",
	HandlerType: (*ManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServerId",
			Handler:    _ManagementService_GetServerId_Handler,
		},
		{
			MethodName: "UpdateServerId",
			Handler:    _ManagementService_UpdateServerId_Handler,
		},
		{
			MethodName: "SetServingReadiness",
			Handler:    _ManagementService_SetServingReadiness_Handler,
		},
		{
			MethodName: "ListDatabases",
			Handler:    _ManagementService_ListDatabases_Handler,
		},
		{
			MethodName: "GetDatabase",
			Handler:    _ManagementService_GetDatabase_Handler,
		},
		{
			MethodName: "CreateDatabase",
			Handler:    _ManagementService_CreateDatabase_Handler,
		},
		{
			MethodName: "UpdateDatabase",
			Handler:    _ManagementService_UpdateDatabase_Handler,
		},
		{
			MethodName: "ListChunks",
			Handler:    _ManagementService_ListChunks_Handler,
		},
		{
			MethodName: "ListRemotes",
			Handler:    _ManagementService_ListRemotes_Handler,
		},
		{
			MethodName: "UpdateRemote",
			Handler:    _ManagementService_UpdateRemote_Handler,
		},
		{
			MethodName: "DeleteRemote",
			Handler:    _ManagementService_DeleteRemote_Handler,
		},
		{
			MethodName: "CreateDummyJob",
			Handler:    _ManagementService_CreateDummyJob_Handler,
		},
		{
			MethodName: "ListPartitions",
			Handler:    _ManagementService_ListPartitions_Handler,
		},
		{
			MethodName: "GetPartition",
			Handler:    _ManagementService_GetPartition_Handler,
		},
		{
			MethodName: "ListPartitionChunks",
			Handler:    _ManagementService_ListPartitionChunks_Handler,
		},
		{
			MethodName: "NewPartitionChunk",
			Handler:    _ManagementService_NewPartitionChunk_Handler,
		},
		{
			MethodName: "ClosePartitionChunk",
			Handler:    _ManagementService_ClosePartitionChunk_Handler,
		},
		{
			MethodName: "UnloadPartitionChunk",
			Handler:    _ManagementService_UnloadPartitionChunk_Handler,
		},
		{
			MethodName: "GetServerStatus",
			Handler:    _ManagementService_GetServerStatus_Handler,
		},
		{
			MethodName: "WipePreservedCatalog",
			Handler:    _ManagementService_WipePreservedCatalog_Handler,
		},
		{
			MethodName: "SkipReplay",
			Handler:    _ManagementService_SkipReplay_Handler,
		},
		{
			MethodName: "DropPartition",
			Handler:    _ManagementService_DropPartition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "influxdata/iox/management/v1/service.proto",
}
